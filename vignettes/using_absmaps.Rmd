---
title: "Using the absmaps package"
author: "Will Mackey"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using the absmaps package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(dplyr)
library(ggplot2)
library(readr)

```


The `absmaps` package has two main components:

1. A set of compressed and tidied lazily-loadable `sf` objects containing geometric information about ASGS structures; and
1. `load_absmaps` function to neatly download and process ASGS data for use. This function: 
    1. **downloads** particular geospatial data (`maps`) from the Australian Bureau of Statistics (`abs`);
    * This presently includes the `sa1`, `sa2`, `sa3`, `sa4`, `gcc`, `ra` and `state` ASGS structures from 2011 and 2016, with more to be included with time.
    1. **compresses** the original 'shapefile' data to something more manageable, without losing important detail;
    1. **converts** the shapefile data to an `sf` (simple feature) object;
    1. **saves** and **loads** the resulting `sf` object for easy use with `dplyr` and `ggplot`.


Before we get into the 'what problem is this package solving' details, let's look at some examples so that you can copy-paste into your own console and replicate out-of-the-box. 


## Just show me how to make a map with this package

### Using the package's pre-loaded data

The `absmaps` package comes with pre-downloaded and pre-processed data. To load a particular geospatial object, simply load the package and call the object:

```{r}
library(absmaps)

mapdata1 <- sa42011

head(mapdata1)
```

Or

```{r}
mapdata2 <- sa22016

head(mapdata2)
```


The resulting `sf` object contains one observation per area (in this example, one observation per `sa4`). It stores the geometry information in the `geometry` variable, which is a nested list describing the area's polygon. The object can be joined to a standard `data.frame` or `tibble` and can be used with `dplyr` functions.


### Using the `load_absmaps` function
The function `load_absmaps`, with `download = TRUE` (the default), will download, compress, convert and load the spatial data you request. The resulting `sf` object will be saved to your global environment to use.

```{r, eval=FALSE}

load_absmaps("sa4", year = 2016, download = TRUE, compress = 0.2)

```

```{r, include=FALSE}
library(absmaps)

mapdata3 <- load_absmaps("sa4", year = 2016, download = FALSE)

```

Like the pre-loaded `sf` objects, the `load_absmaps` `sf` object contains one observation per area and stores the geometry information in the `geometry` list variable. It can be joined to a standard `data.frame` or `tibble` and can be used with `dplyr` functions.


### Creating maps with your `sf` object
We do all this so we can create gorgeous maps. And with the `sf` object in hand, plotting a map via `ggplot` and `geom_sf` is simple.

```{r}
map <- 
sa42016 %>% 
  filter(gcc == "Greater Melbourne") %>%   # let's just look Melbourne
  ggplot() +
  geom_sf(aes(geometry = geometry))  # use the geometry variable

map
```

The `load_absmaps` package also calculates the centorids of each area, and we can add these points to the map with the `cent_lat` and `cent_long` variables using `geom_point`.

```{r}
map <- 
sa42016 %>% 
  filter(gcc == "Greater Melbourne") %>%   # let's just look Melbourne
  ggplot() +
  geom_sf(aes(geometry = geometry)) +   # use the geometry variable
  geom_point(aes(cent_lat, cent_long))  # use the centroid lat and longs

map
```

Cool. But, sidenote, this all looks a bit ugly. We can clear it up using `ggplot` tweaks. See the comments on each line for its objective. Also note that we're filling the areas by their `areasqkm` size, another variable included in the `sf` object (we'll replace this with more interesting data in the next section).

```{r}
map <- 
sa42016 %>% 
  filter(gcc == "Greater Melbourne") %>%   # let's just look Melbourne
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
              fill = areasqkm),     # fill by area size
          lwd = 0,                  # remove borders
          show.legend = FALSE) +    # remove legend
  geom_point(aes(cent_lat,      
                 cent_long),        # use the centroid lat and longs
             colour = "white") +    # make the points white
  theme_void() +                    # clears other plot elements
  coord_sf(datum = NA)              # fixes a gridline bug in theme_void()

map
```



## Joining with actual data

At some point, we'll want to join our spatial data with data-of-interest. The variables in our mapping data---stating the numeric code and name of each area and parent area---will make this _relatively_ easy.

For example: we have a simple dataset of the unemployment rate in each `sa4` in each `year` (conveniently retrieved using the `readabs` [package](https://cran.r-project.org/web/packages/readabs/readabs.pdf)). 

```{r}
# Read data in
ue_data <- read_csv("data/ue_data.csv")

# This data contains a variable of sa4 that can be joined to the sa42016 set:
ue_data <- ue_data %>% left_join(sa42016)
```

Now that we have a tidy dataset with 1) the unemployment data we want to plot, and 2) the geometry of the areas, we can plot unemployment rates by area:

```{r}
map <- 
ue_data %>% 
  filter(gcc == "Greater Melbourne") %>%   # let's just look Melbourne
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
              fill = ue_pc),        # fill by unemployment rate
          lwd = 0) +                # remove borders
  theme_void() +                    # clears other plot elements
  coord_sf(datum = NA)              # fixes a gridline bug in theme_void()

map
```


If we zoom out, we notice that not all SA4's have been matched with a geometry:

```{r}
map <- 
ue_data %>% 
  ggplot() +
  geom_sf(aes(geometry = geometry,  # use the geometry variable
              fill = ue_pc),        # fill by unemployment rate
          lwd = 0) +                # remove borders
  theme_void() +                    # clears other plot elements
  coord_sf(datum = NA) +            # fixes a gridline bug in theme_void()
  theme(legend.position = "off")

map
```


This is because the ABS has used (in this time series) the 2011 version of SA4s. We will need to use `correspond_absmaps` to 


## Why does this package exist?

The motivation for this package is that maps are cool and fun and are, sometimes, the best way to communicate data.
And making maps is `R` with `ggplot` is relatively easy _when you have the right `object`_. 

Getting the right `object` is not technically difficult, but requires research into the best-thing-to-do at each of the following steps:

*  Find the ASGS ABS spatial-data page and determine the right file to download.
*  Read the shapefile into `R` using one-of-many import tools.
*  Convert the object into something usable. 
*  Clean up any inconsistencies and apply consistent variable naming/values across areas and years.
*  Find an appropriate compression function and level to optimise output.

For me, at least, finding the correct information and developing the best set of steps was a little bit interesting but mostly tedious and annoying. The `absmaps` package does this for you so you can spend more time making maps, and less time on Stack Overflow, the ABS website, and [lovely-people's kind-of-confusing blogs](https://www.neonscience.org/dc-open-shapefiles-r).


## How does this package do-the-things-it-does

The `absmaps` package uses four key functions to do-the-things-it-does:

*  `utils::download.file` to download shapefile data from the ABS.
*  `sf::st_read` to read the shapefile into an `sf` object.
*  `rmapshaper::ms_simplify` to nicely compress the `sf` object.
*  `readr::write_rds` to write, and `readr::read_rds` to read our nice `sf` objects.

There are a bunch of other fiddley-things on top of that, but those four steps are the 'workhorse' functions. A big thanks to people who built them.

If you're interested, check out `load_absmaps.R` code in the `R/` file. And, of course, if you have a suggestion to improve, please do let me know via an issue at https://github.com/wfmackey/absmaps.
